<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voxel Engine | Corner Shaded</title>
    <style>
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100vw; height: 100vh; image-rendering: pixelated; }
        #ui { 
            position: absolute; top: 15px; left: 15px; color: #0f0; 
            background: rgba(0,0,0,0.85); padding: 12px; border: 1px solid #0f0; 
            pointer-events: none; z-index: 10; text-transform: uppercase; font-size: 11px;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            border: 1px solid rgba(0, 255, 0, 0.5); transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #hammer {
            position: absolute; bottom: -20px; right: 10%; width: 200px; height: 300px;
            background: linear-gradient(to top, #333, #777);
            clip-path: polygon(40% 100%, 60% 100%, 60% 40%, 90% 40%, 90% 0%, 10% 0%, 10% 40%, 40% 40%);
            transform-origin: bottom center; transition: transform 0.1s; pointer-events: none;
        }
        .val { color: #fff; }
    </style>
</head>
<body>
    <div id="ui">
        FPS: <span id="fps" class="val">0</span> | OBJ: <span id="obj-status" class="val">WAITING</span><br>
        POS: <span id="pos" class="val">0,0,0</span><br>
        L/R CLICK: INTERACT | CTRL: SPRINT
    </div>
    <div id="crosshair"></div>
    <div id="hammer"></div>
    <canvas id="c"></canvas>

<script type="x-shader/x-vertex" id="vs">#version 300 es
    layout(location = 0) in vec2 position;
    void main() { gl_Position = vec4(position, 0.0, 1.0); }
</script>

<script type="x-shader/x-fragment" id="fs">#version 300 es
precision highp float;
precision highp sampler3D;
uniform vec2 u_res;
uniform vec3 u_camPos;
uniform vec3 u_camDir;
uniform vec3 u_camUp;
uniform float u_fov;
uniform sampler3D u_voxels;
uniform vec3 u_selectedBlock;

out vec4 fragColor;

const float GRID = 256.0;
const int MAX_STEPS = 160; 

// Check if a voxel is solid
bool isSolid(ivec3 pos) {
    if(pos.x < 0 || pos.x >= int(GRID) || pos.y <= 18 || pos.y >= int(GRID) || pos.z < 0 || pos.z >= int(GRID)) {
        return pos.y <= 18;
    }
    return texelFetch(u_voxels, pos, 0).r > 0.5;
}

// Calculate vertex ambient occlusion for a corner
float vertexAO(ivec3 pos, vec3 normal, vec3 corner) {
    // Get the two edges and the diagonal corner relative to the face
    vec3 side1 = vec3(corner.x, 0.0, 0.0);
    vec3 side2 = vec3(0.0, corner.y, 0.0);
    vec3 diag = corner;
    
    // For X-facing normals
    if(abs(normal.x) > 0.5) {
        side1 = vec3(0.0, corner.y, 0.0);
        side2 = vec3(0.0, 0.0, corner.z);
        diag = vec3(0.0, corner.y, corner.z);
    }
    // For Y-facing normals
    else if(abs(normal.y) > 0.5) {
        side1 = vec3(corner.x, 0.0, 0.0);
        side2 = vec3(0.0, 0.0, corner.z);
        diag = vec3(corner.x, 0.0, corner.z);
    }
    // For Z-facing normals
    else {
        side1 = vec3(corner.x, 0.0, 0.0);
        side2 = vec3(0.0, corner.y, 0.0);
        diag = vec3(corner.x, corner.y, 0.0);
    }
    
    ivec3 checkPos = pos + ivec3(normal);
    bool s1 = isSolid(checkPos + ivec3(side1));
    bool s2 = isSolid(checkPos + ivec3(side2));
    bool dc = isSolid(checkPos + ivec3(diag));
    
    // Minecraft-style AO formula
    if(s1 && s2) return 0.0; // Darkest - both edges blocked
    return 1.0 - (float(s1) + float(s2) + float(dc)) / 3.0;
}

// Calculate smooth corner shading for the hit point
float getCornerAO(vec3 hitPos, ivec3 voxelPos, vec3 normal) {
    // Get the fractional position within the voxel face
    vec3 localPos = fract(hitPos);
    
    // Calculate the 4 corner AO values based on face normal
    float ao00, ao01, ao10, ao11;
    
    if(abs(normal.y) > 0.5) {
        // Top/Bottom face
        ao00 = vertexAO(voxelPos, normal, vec3(-1.0, 0.0, -1.0));
        ao01 = vertexAO(voxelPos, normal, vec3(-1.0, 0.0,  1.0));
        ao10 = vertexAO(voxelPos, normal, vec3( 1.0, 0.0, -1.0));
        ao11 = vertexAO(voxelPos, normal, vec3( 1.0, 0.0,  1.0));
        
        // Bilinear interpolation
        float ao0 = mix(ao00, ao01, localPos.z);
        float ao1 = mix(ao10, ao11, localPos.z);
        return mix(ao0, ao1, localPos.x);
    }
    else if(abs(normal.x) > 0.5) {
        // Left/Right face
        ao00 = vertexAO(voxelPos, normal, vec3(0.0, -1.0, -1.0));
        ao01 = vertexAO(voxelPos, normal, vec3(0.0, -1.0,  1.0));
        ao10 = vertexAO(voxelPos, normal, vec3(0.0,  1.0, -1.0));
        ao11 = vertexAO(voxelPos, normal, vec3(0.0,  1.0,  1.0));
        
        float ao0 = mix(ao00, ao01, localPos.z);
        float ao1 = mix(ao10, ao11, localPos.z);
        return mix(ao0, ao1, localPos.y);
    }
    else {
        // Front/Back face
        ao00 = vertexAO(voxelPos, normal, vec3(-1.0, -1.0, 0.0));
        ao01 = vertexAO(voxelPos, normal, vec3( 1.0, -1.0, 0.0));
        ao10 = vertexAO(voxelPos, normal, vec3(-1.0,  1.0, 0.0));
        ao11 = vertexAO(voxelPos, normal, vec3( 1.0,  1.0, 0.0));
        
        float ao0 = mix(ao00, ao01, localPos.x);
        float ao1 = mix(ao10, ao11, localPos.x);
        return mix(ao0, ao1, localPos.y);
    }
}

void main() {
    vec2 uv = (2.0 * gl_FragCoord.xy - u_res.xy) / min(u_res.y, u_res.x);
    vec3 cw = normalize(u_camDir);
    vec3 cu = normalize(cross(cw, u_camUp));
    vec3 cv = normalize(cross(cu, cw));
    vec3 rd = normalize(uv.x * cu + uv.y * cv + u_fov * cw);
    
    vec3 ro = u_camPos * GRID;
    vec3 mapPos = floor(ro);
    vec3 rdInv = 1.0 / (rd + 1e-7); 
    vec3 stepDir = sign(rd);
    vec3 tDelta = abs(rdInv);
    vec3 tMax = (stepDir * (mapPos - ro) + 0.5 + stepDir * 0.5) * tDelta;
    
    vec3 mask = vec3(0.0);
    bool hit = false;
    float floorHit = -1.0;
    int i;
    float hitT = 0.0;

    for (i = 0; i < MAX_STEPS; i++) {
        if (mapPos.x >= 0.0 && mapPos.x < GRID && mapPos.z >= 0.0 && mapPos.z < GRID) {
            if (mapPos.y <= 18.0) { floorHit = float(i); break; }
            if (mapPos.y < GRID && texelFetch(u_voxels, ivec3(mapPos), 0).r > 0.5) { 
                hit = true;
                // Calculate hit point for smooth AO
                if(mask.x > 0.5) hitT = tMax.x - tDelta.x;
                else if(mask.y > 0.5) hitT = tMax.y - tDelta.y;
                else if(mask.z > 0.5) hitT = tMax.z - tDelta.z;
                break; 
            }
        } else if (i > 80) break;
        
        mask = step(tMax.xyz, tMax.yzx) * step(tMax.xyz, tMax.zxy);
        tMax += mask * tDelta;
        mapPos += mask * stepDir;
    }

    vec3 sky = vec3(0.01, 0.02, 0.04);
    float d = float(i) / float(MAX_STEPS);

    if (hit) {
        // Calculate normal and hit position
        vec3 normal = -mask * stepDir;
        vec3 hitPos = ro + rd * hitT;
        
        // Get smooth corner AO
        float cornerAO = getCornerAO(hitPos, ivec3(mapPos), normal);
        
        // Apply stronger AO effect
        cornerAO = pow(cornerAO, 1.5) * 0.7 + 0.3;
        
        // Directional lighting
        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.3));
        float diffuse = max(dot(normal, lightDir), 0.0);
        
        // Enhanced face shading based on normal direction
        float faceShade = 1.0;
        if(abs(normal.y) > 0.5) {
            faceShade = normal.y > 0.0 ? 1.0 : 0.5;
        } else if(abs(normal.x) > 0.5) {
            faceShade = 0.75;
        } else {
            faceShade = 0.65;
        }
        
        // Combine lighting with corner AO
        float lighting = (diffuse * 0.6 + 0.4) * faceShade * cornerAO;
        
        // Base color with lighting
        vec3 baseColor = vec3(0.4, 0.7, 1.0);
        vec3 col = baseColor * lighting;
        
        // Add subtle rim lighting
        float rim = pow(1.0 - abs(dot(normalize(rd), normal)), 2.0) * 0.2;
        col += rim * vec3(0.3, 0.5, 0.8) * cornerAO;
        
        // Selection highlight
        if (floor(u_selectedBlock/2.0) == floor(mapPos/2.0)) {
            col *= 1.5;
            col += vec3(0.2, 0.3, 0.1);
        }
        
        fragColor = vec4(mix(col, sky, d*d*0.8), 1.0);
    } else if (floorHit > 0.0) {
        float grid = mod(floor(mapPos.x/4.0) + floor(mapPos.z/4.0), 2.0);
        vec3 col = mix(vec3(0.08, 0.1, 0.15), vec3(0.04, 0.05, 0.08), grid);
        fragColor = vec4(mix(col, sky, pow(d, 1.5)), 1.0);
    } else {
        fragColor = vec4(sky, 1.0);
    }
}
</script>

<script type="module">
    const canvas = document.getElementById('c');
    const hammerEl = document.getElementById('hammer');
    const gl = canvas.getContext('webgl2', { antialias: false });
    
    if (!gl) { alert("WebGL2 not supported"); }

    const posEl = document.getElementById('pos'), fpsEl = document.getElementById('fps'), objStatus = document.getElementById('obj-status');

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source.trim());
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const vsSource = document.getElementById('vs').text;
    const fsSource = document.getElementById('fs').text;
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        alert("Could not link shaders: " + gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // Buffers
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const posAttrib = gl.getAttribLocation(program, "position");
    gl.enableVertexAttribArray(posAttrib);
    gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0);

    const GRID = 256;
    const voxelData = new Uint8Array(GRID ** 3);
    const tex = gl.createTexture();
    
    const PLAYER_WIDTH = 1.4/GRID, PLAYER_HEIGHT = 3.6/GRID, EYE_HEIGHT = 3.2/GRID, STEP_HEIGHT = 2.1/GRID; 
    const GRAVITY = 2.5/(GRID*GRID), JUMP_VEL = 0.25/GRID, WALK_SPEED = 0.06/GRID;

    let camPos = { x: 0.5, y: 0.1, z: 0.5 }, renderCamY = 0.1 + EYE_HEIGHT; 
    let camYaw = -1.57, camPitch = 0, keys = {}, velY = 0;
    let onGround = false, lastT = 0, frameCount = 0, nextUpdate = 0;
    let selectedBlock = {x:-1, y:-1, z:-1}, placePos = {x:-1, y:-1, z:-1};

    const uRes = gl.getUniformLocation(program, "u_res"), uPos = gl.getUniformLocation(program, "u_camPos");
    const uDir = gl.getUniformLocation(program, "u_camDir"), uUp = gl.getUniformLocation(program, "u_camUp");
    const uFov = gl.getUniformLocation(program, "u_fov"), uSel = gl.getUniformLocation(program, "u_selectedBlock");

    function resize() { 
        canvas.width = window.innerWidth / 1.5; 
        canvas.height = window.innerHeight / 1.5; 
        gl.viewport(0, 0, canvas.width, canvas.height); 
    }
    window.addEventListener('resize', resize); resize();

    function updateTexture() {
        gl.bindTexture(gl.TEXTURE_3D, tex);
        gl.texImage3D(gl.TEXTURE_3D, 0, gl.R8, GRID, GRID, GRID, 0, gl.RED, gl.UNSIGNED_BYTE, voxelData);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }

    async function loadOBJ(url) {
        try {
            const res = await fetch(url);
            if(!res.ok) throw new Error();
            const text = await res.text();
            const verts = [], lines = text.split('\n');
            let min = [1e9,1e9,1e9], max = [-1e9,-1e9,-1e9];
            lines.forEach(l => { 
                if (l.startsWith('v ')) { 
                    const v = l.split(/\s+/).slice(1,4).map(Number); 
                    verts.push(v); v.forEach((c,i) => { min[i]=Math.min(min[i],c); max[i]=Math.max(max[i],c); }); 
                }
            });
            const sz = Math.max(...max.map((m,i)=>m-min[i]));
            lines.forEach(l => { 
                if (l.startsWith('f ')) {
                    const f = l.trim().split(/\s+/).slice(1).map(s => parseInt(s.split('/')[0])-1);
                    const v = [verts[f[0]], verts[f[1]], verts[f[2]]];
                    for(let k=0; k<6; k++){
                        const a=Math.random(), b=Math.random(); if(a+b>1) continue;
                        const px = Math.floor((v[0][0]*(1-a-b)+v[1][0]*a+v[2][0]*b-min[0])/sz*180+38);
                        const py = Math.floor((v[0][1]*(1-a-b)+v[1][1]*a+v[2][1]*b-min[1])/sz*180+20);
                        const pz = Math.floor((v[0][2]*(1-a-b)+v[1][2]*a+v[2][2]*b-min[2])/sz*180+38);
                        if(px>=0 && px<GRID && py>18 && py<GRID && pz>=0 && pz<GRID) voxelData[px + py*GRID + pz*GRID*GRID] = 255;
                    }
                }
            });
            objStatus.innerText = "LOADED";
        } catch(e) { 
            objStatus.innerText = "NONE (GENERATE)";
            for(let i=0; i<10; i++) {
                for(let x=124; x<132; x++)
                    for(let z=130+i*3; z<160; z++)
                        for(let y=0; y<2; y++) voxelData[x + (19+i*2+y)*GRID + z*GRID*GRID] = 255;
            }
        }
        updateTexture();
    }

    function modifyBlock(pos, state) {
        let bx = Math.floor(pos.x/2)*2, by = Math.floor(pos.y/2)*2, bz = Math.floor(pos.z/2)*2;
        for(let x=0; x<2; x++) for(let y=0; y<2; y++) for(let z=0; z<2; z++) {
            let px=bx+x, py=by+y, pz=bz+z;
            if(px>=0 && px<GRID && py>18 && py<GRID && pz>=0 && pz<GRID) voxelData[px + py*GRID + pz*GRID*GRID] = state;
        }
        updateTexture();
    }

    function isColliding(box) {
        const x0 = Math.floor(box.minX * GRID), x1 = Math.floor(box.maxX * GRID);
        const y0 = Math.floor(box.minY * GRID), y1 = Math.floor(box.maxY * GRID);
        const z0 = Math.floor(box.minZ * GRID), z1 = Math.floor(box.maxZ * GRID);
        for (let x = x0; x <= x1; x++) for (let y = y0; y <= y1; y++) for (let z = z0; z <= z1; z++) {
            if (y <= 18) return true; 
            if (x >= 0 && x < GRID && y >= 0 && y < GRID && z >= 0 && z < GRID) {
                if (voxelData[x + y * GRID + z * GRID * GRID] > 0) return true;
            }
        }
        return false;
    }

    function raycast() {
        let ro = {x: camPos.x * GRID, y: (camPos.y + EYE_HEIGHT) * GRID, z: camPos.z * GRID};
        let rd = {x: Math.cos(camPitch)*Math.cos(camYaw), y: Math.sin(camPitch), z: Math.cos(camPitch)*Math.sin(camYaw)};
        let pos = {x: Math.floor(ro.x), y: Math.floor(ro.y), z: Math.floor(ro.z)};
        let stepDir = {x: Math.sign(rd.x), y: Math.sign(rd.y), z: Math.sign(rd.z)};
        let tDelta = {x: Math.abs(1/rd.x), y: Math.abs(1/rd.y), z: Math.abs(1/rd.z)};
        let tMax = {x: (stepDir.x > 0 ? pos.x+1-ro.x : ro.x-pos.x) * tDelta.x, y: (stepDir.y > 0 ? pos.y+1-ro.y : ro.y-pos.y) * tDelta.y, z: (stepDir.z > 0 ? pos.z+1-ro.z : ro.z-pos.z) * tDelta.z};
        let lastPos = {...pos};
        for (let i = 0; i < 40; i++) {
            if (pos.y <= 18 || (pos.x>=0 && pos.x<GRID && pos.y>=0 && pos.y<GRID && pos.z>=0 && pos.z<GRID && voxelData[pos.x + pos.y*GRID + pos.z*GRID*GRID] > 0)) {
                selectedBlock = pos; placePos = lastPos; return;
            }
            lastPos = {...pos};
            if (tMax.x < tMax.y && tMax.x < tMax.z) { tMax.x += tDelta.x; pos.x += stepDir.x; }
            else if (tMax.y < tMax.z) { tMax.y += tDelta.y; pos.y += stepDir.y; }
            else { tMax.z += tDelta.z; pos.z += stepDir.z; }
        }
        selectedBlock = {x:-1,y:-1,z:-1};
    }

    canvas.onmousedown = (e) => {
        if (document.pointerLockElement !== canvas) { canvas.requestPointerLock(); return; }
        hammerEl.style.transform = "rotate(-25deg) translateY(-15px)";
        setTimeout(() => hammerEl.style.transform = "rotate(0deg) translateY(0)", 100);
        if (selectedBlock.x === -1) return;
        if (e.button === 0) modifyBlock(selectedBlock, 0); 
        else if (e.button === 2) modifyBlock(placePos, 255);
    };

    window.onkeydown = e => keys[e.code] = true;
    window.onkeyup = e => keys[e.code] = false;
    window.onmousemove = e => { if(document.pointerLockElement===canvas){ camYaw += e.movementX * 0.0012; camPitch = Math.max(-1.4, Math.min(1.4, camPitch - e.movementY * 0.0012)); }};
    window.oncontextmenu = e => e.preventDefault();

    function render(t) {
        const dt = Math.min((t - lastT) / 1000, 0.1); lastT = t;
        frameCount++;
        if (t > nextUpdate) { 
            fpsEl.innerText = frameCount * 2; frameCount = 0; 
            posEl.innerText = `${(camPos.x * GRID).toFixed(0)}, ${(camPos.y * GRID).toFixed(0)}, ${(camPos.z * GRID).toFixed(0)}`;
            nextUpdate = t + 500; 
        }

        const speed = (keys['ControlLeft'] ? 1.6 : 1.0) * WALK_SPEED * dt * 60;
        let wishX = (keys['KeyW']?1:keys['KeyS']?-1:0), wishZ = (keys['KeyA']?1:keys['KeyD']?-1:0);
        let moveX = (wishX * Math.cos(camYaw) + wishZ * Math.sin(camYaw)) * speed;
        let moveZ = (wishX * Math.sin(camYaw) - wishZ * Math.cos(camYaw)) * speed;

        velY -= GRAVITY; if (keys['Space'] && onGround) { velY = JUMP_VEL; onGround = false; }

        let nX = camPos.x + moveX, nZ = camPos.z + moveZ;
        const box = (x, y, z) => ({ minX: x - PLAYER_WIDTH/2, maxX: x + PLAYER_WIDTH/2, minY: y, maxY: y + PLAYER_HEIGHT, minZ: z - PLAYER_WIDTH/2, maxZ: z + PLAYER_WIDTH/2 });

        if (!isColliding(box(nX, camPos.y, nZ))) { camPos.x = nX; camPos.z = nZ; } 
        else if (onGround && !isColliding(box(nX, camPos.y + STEP_HEIGHT, nZ))) { camPos.x = nX; camPos.z = nZ; camPos.y += STEP_HEIGHT; }

        camPos.y += velY; onGround = false;
        if (isColliding(box(camPos.x, camPos.y, camPos.z))) { if (velY < 0) onGround = true; camPos.y -= velY; velY = 0; }

        renderCamY += (camPos.y + EYE_HEIGHT - renderCamY) * 0.15; 
        raycast();

        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform3f(uPos, camPos.x, renderCamY, camPos.z);
        gl.uniform3f(uDir, Math.cos(camPitch)*Math.cos(camYaw), Math.sin(camPitch), Math.cos(camPitch)*Math.sin(camYaw));
        gl.uniform3f(uUp, 0, 1, 0);
        gl.uniform1f(uFov, keys['ControlLeft'] ? 1.3 : 1.5);
        gl.uniform3f(uSel, selectedBlock.x, selectedBlock.y, selectedBlock.z);
        
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }
    
    loadOBJ('model.obj').then(() => requestAnimationFrame(render));
    updateTexture();
</script>
</body>
</html>